package me.devnatan.katan.api.server

import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.channels.BroadcastChannel
import kotlinx.coroutines.channels.Channel
import me.devnatan.katan.api.annotations.InternalKatanApi
import me.devnatan.katan.api.annotations.UnstableKatanApi
import kotlin.reflect.KClass
import kotlin.reflect.KParameter
import kotlin.reflect.full.primaryConstructor
import kotlin.reflect.jvm.jvmErasure

abstract class ServerCompositionFactory(val registrations: MutableMap<String, ServerComposition.Key<*>>) {

    constructor() : this(hashMapOf())

    @InternalKatanApi
    @ExperimentalCoroutinesApi
    val channel = BroadcastChannel<ServerCompositionPacket>(Channel.BUFFERED)

    abstract suspend fun create(key: ServerComposition.Key<*>, options: ServerCompositionOptions): ServerComposition<*>

    abstract suspend fun generate(key: ServerComposition.Key<*>, data: Map<String, Any>): ServerCompositionOptions

}

fun ServerCompositionFactory.getKey(name: String): ServerComposition.Key<*>? {
    return registrations[name]
}

fun ServerCompositionFactory.getKeyName(key: ServerComposition.Key<*>): String? {
    return registrations.entries.firstOrNull { it.value == key }?.key
}

inline fun <reified T : ServerComposition.Key<*>> ServerCompositionFactory.addSupportedKey(key: T) {
    addSupportedKey(T::class.simpleName!!.toLowerCase(), key)
}

fun ServerCompositionFactory.addSupportedKey(name: String, key: ServerComposition.Key<*>) {
    registrations[name] = key
}

@UnstableKatanApi
@OptIn(ExperimentalCoroutinesApi::class, InternalKatanApi::class)
suspend inline fun ServerCompositionFactory.prompt(text: String, defaultValue: String? = null): String {
    val job = CompletableDeferred<String>()
    val packet = ServerCompositionPacket.Prompt(text, defaultValue, job)
    channel.send(packet)
    return job.await()
}

@UnstableKatanApi
@OptIn(ExperimentalCoroutinesApi::class, InternalKatanApi::class)
suspend inline fun ServerCompositionFactory.message(text: String, error: Boolean = false) {
    channel.send(ServerCompositionPacket.Message(text, error))
}

@UnstableKatanApi
@OptIn(ExperimentalCoroutinesApi::class, InternalKatanApi::class)
suspend inline fun ServerCompositionFactory.close() {
    channel.send(ServerCompositionPacket.Close)
}

@InternalKatanApi
fun resolveServerCompositionFactoryOptions(type: KClass<out Any>, data: Map<String, Any>): Any {
    val caller = type.primaryConstructor!!
    val values = hashMapOf<KParameter, Any?>()
    for (parameter in caller.parameters) {
        val value = data[parameter.name]
        val result = if (value is Map<*, *>) resolveServerCompositionFactoryOptions(
            parameter.type.jvmErasure,
            value as Map<String, Any>
        ) else value
        values[parameter] = result
    }
    return caller.callBy(values)
}

@UnstableKatanApi
@OptIn(InternalKatanApi::class)
inline fun <reified T : ServerCompositionOptions> useAutoGeneratedOptions(data: Map<String, Any>): T {
    return resolveServerCompositionFactoryOptions(T::class, data) as T
}